Участники: Крестьянова Елизавета, Дашкевич Олеся.
# Docker
## "Плохой" Dockerfile
> Написать “плохой” Dockerfile, в котором есть не менее трех “bad practices” по написанию докерфайлов  

```
FROM ubuntu:latest

RUN apt-get update
RUN apt-get install -y libaa-bin
RUN apt-get install -y iputils-ping
```

Построим образ на основе этого файла и создадим контейнер:

![alt text](<../images/photo_2024-10-20_03-24-29.jpg>)

Как видно на скриншоте, вход в контейнер осуществляется за root.

## "Хороший" Dockerfile
> Написать “хороший” Dockerfile, в котором эти плохие практики исправлены

```
FROM ubuntu:22.04

RUN apt-get update && apt-get install -y \
        iputils-ping \
        libaa-bin && adduser itmostudent

USER itmostudent
```

Построим образ на основе этого файла и создадим контейнер:

![alt text](<../images/photo_2024-10-20_03-23-36.jpg>)

В этот же раз видно, что мы входим за пользователя itmostudent, а не за root.

## Описание плохих практик и их исправление
> В Readme описать каждую из плохих практик в плохом докерфайле, почему она плохая и как в хорошем она была исправлена, как исправление повлияло на результат

### 1. Запуск контейнера под пользователя root
 По умолчанию Docker контейнеры запускаются под root, что может быть полезно во время разработки или для специфичных случаев; но эта конфигурация ставит под риск все ресурсы контейнера. Потенциально, даже систему хоста. Хотя изоляция между контейнерами и хостом сильна, есть шанс, что злоумышленник может найти уязвимости в приложении или даже в самом ядре ОС хоста. 
 Пусть шанс, что злоумышленник может выйти за рамки контейнера, мал, лучше перестраховаться и определить пользователя для контейнера с минимально нужными правами.
 Для исправления этой уязвимости можно указать юзера как через UID с GID:
```
USER 1001:1001
```
Так и через команду RUN:
```
RUN adduser itmostudent
USER itmostudent
```
В этом случае UID и GUI задаются через команду useradd. Через RUN можно так же создать группу и/или добавить пользователя в группу.
Если для работы контейнера необходимы зайти под root, можно указать USER root, нужные команды, и вернуться обратно на USER itmostudent (sudo не рекомендуют использовать для контейнеров). В хорошем же примере контейнер переключается на itmostudent после установки всех нужных пакетов.
### 2. Указание :latest версии
Что такое :latest? :latest это тег, указывает на самый свежий образ, у которого нет своего тега. То есть он не всегда указывает на самую последнюю версию образа, которую пушнули: последним версиям могли присвоить какие-либо теги, к примеру, и :latest их не стянет.
Если не считать конфуза с наименованием, у :latest есть и другие проблемы.
Эта конфигурация приводит к нестабильности контейнера. Приложение может прекратить корректно работать из-за какого-либо нового обновления. К тому же, далеко не всегда можно понять, что всё сломалось из-за обновления, а не из-за ошибке в коде, что не помогает процесу дебага.
Лучше всего указывать конкретную версию, как, например, в хорошем примере `FROM ubuntu:22.04.`  Тогда разработчикам становится яснее, с какой версией образа работает программа, и сама она от этого стабильнее.
### 3. Несколько RUN инструкций
В плохом примере есть плохая проблема с тем, что строки RUN apt-get update и строки установки RUN apt-get install друг от друга отделены. Это создаёт отдельные слои поверх образа, которые записываются в кэш докера. 
Допустим, нам надо поменять строчку установки, будем устанавливать какой-нибудь nginx, например. При перестройке образа Docker заметит, что эту инструкцию поменяли, он её выполнит и перезапишет её в кэш. А вот инструкция RUN apt-get update не менялась, поэтому Docker использует версию из кэша, а не исполнит её. Что грозит установкой устаревшей версии nginx. 
Поэтому хорошая практика соединять эти инструкции вместе через &&: 
`RUN apt-get update && apt-get install -y`
Но если нам надо установить несколько пакетов, все их прописывать на одной строке нежелательно, поэтому мы можем их разделить на несколько строк через `\` , что показано на хорошем примере.
В таком случае рекоммендуют размещать названия пакетов по алфавиту для удобства чтения. 

Для наглядности: официальный пример из документации Docker, где все эти рекоммендации учтены:
```
RUN apt-get update && apt-get install -y \
    aufs-tools \
    automake \
    build-essential \
    curl \
    dpkg-sig \
    libcap-dev \
    libsqlite3-dev \
    mercurial \
    reprepro \
    ruby1.9.1 \
    ruby1.9.1-dev \
    s3cmd=1.1.* \
    && rm -rf /var/lib/apt/lists/*
```
## Плохие практики работы с Docker
> В Readme описать 2 плохих практики по работе с контейнерами. ! Не по написанию докерфайлов, а о том, как даже используя хороший докерфайл можно накосячить именно в работе с контейнерами.

### 1. Относиться к контейнерам как к виртуальным машинам
Контейнеры это не виртуальные машины, мы не запускаем программы в контейнерах, напрямую не подключаемся, вручную не настраиваем ничего, не храним там данные. Контейнер идейно должен работать у каждого пользователя и разработчика одинаково. У вас нет надобности подключаться к контейнеру через ssh, устанавливать там программы и что-то чинить. После следующего ребута все эти изменения всё равно пропадут.

## 2. Несколько приложений в одном контейнере

Контейнеры Docker следует их делать максимально простыми. В том числе надо понимать, что у контейнеров стоит задача заниматься одним процессом (в большинстве случаев). Для удобного тестирования и использования приложений в различных проектах, стоит разделять их по разным контейнерам: например, веб-приложение в одном контейнере, база данных в другом. Если несколько приложений сидят в одном контейнере, и кто-то один сломался, будет сложно разбираться в логах, что произошло, и кто виноват. Или если вам надо будет апгрейдить какой-то из пакетов, на который полагаются несколько приложений, часть сервисов может напрочь отказаться работать с ним - и контейнер прекратит корректно работать.
