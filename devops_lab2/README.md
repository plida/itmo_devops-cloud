Участники: Крестьянова Елизавета, Дашкевич Олеся.
# Docker
## "Плохой" Dockerfile
> Написать “плохой” Dockerfile, в котором есть не менее трех “bad practices” по написанию докерфайлов  

```
FROM ubuntu:latest

RUN apt-get update
RUN apt-get-install -y libaa-bin
RUN apt-get install -y iputils-ping
```

## "Хороший" Dockerfile
> Написать “хороший” Dockerfile, в котором эти плохие практики исправлены

```
FROM ubuntu:22.04

RUN apt-get update && apt-get install -y \
	iputils-ping \
	libaa-bin \
	
RUN useradd -ms itmostudent
USER itmostudent
```

## Описание плохих практик и их исправление
> В Readme описать каждую из плохих практик в плохом докерфайле, почему она плохая и как в хорошем она была исправлена, как исправление повлияло на результат

### 1. Запуск контейнера под пользователя root
 По умолчанию Docker контейнеры запускаются под root, что может быть полезно во время разработки или для специфичных случаев; но эта конфигурация ставит под риск все ресурсы контейнера. Потенциально, даже систему хоста. Хотя изоляция между контейнерами и хостом сильна, есть шанс, что злоумышленник может найти уязвимости в приложении или даже в самом ядре ОС хоста. 
 Пусть шанс, что злоумышленник может выйти за рамки контейнера, мал, лучше перестраховаться и определить пользователя для контейнера с минимально нужными правами.
 Для исправления этой уязвимости можно указать юзера как через UID с GID:
```
USER 1001:1001
```
Так и через команду RUN:
```
RUN useradd -ms itmostudent
USER itmostudent
```
В этом случае UID и GUI задаются через команду useradd. Через RUN можно так же создать группу и/или добавить пользователя в группу.
Если для работы контейнера необходимы зайти под root, можно указать USER root, нужные команды, и вернуться обратно на USER itmostudent (sudo не рекомендуют использовать для контейнеров). В хорошем же примере контейнер переключается на itmostudent после установки всех нужных пакетов.
### 2. Указание :latest версии
Что такое :latest? :latest это тег, указывает на самый свежий образ, у которого нет своего тега. То есть он не всегда указывает на самую последнюю версию образа, которую пушнули: последним версиям могли присвоить какие-либо теги, к примеру, и :latest их не стянет.
Если не считать конфуза с наименованием, у :latest есть и другие проблемы.
Эта конфигурация приводит к нестабильности контейнера. Приложение может прекратить корректно работать из-за какого-либо нового обновления. К тому же, далеко не всегда можно понять, что всё сломалось из-за обновления, а не из-за ошибке в коде, что не помогает процесу дебага.
Лучше всего указывать конкретную версию, как, например, в хорошем примере `FROM ubuntu:22.04.`  Тогда разработчикам становится яснее, с какой версией образа работает программа, и сама она от этого стабильнее.
### 3. Несколько RUN инструкций
В плохом примере есть плохая проблема с тем, что строки RUN apt-get update и строки установки RUN apt-get install друг от друга отделены. Это создаёт отдельные слои поверх образа, которые записываются в кэш докера. 
Допустим, нам надо поменять строчку установки, будем устанавливать какой-нибудь nginx, например. При перестройке образа Docker заметит, что эту инструкцию поменяли, он её выполнит и перезапишет её в кэш. А вот инструкция RUN apt-get update не менялась, поэтому Docker использует версию из кэша, а не исполнит её. Что грозит установкой устаревшей версии nginx. 
Поэтому хорошая практика соединять эти инструкции вместе через &&: 
`RUN apt-get update && apt-get install -y`
Но если нам надо установить несколько пакетов, все их прописывать на одной строке нежелательно, поэтому мы можем их разделить на несколько строк через `\` , что показано на хорошем примере.
В таком случае рекоммендуют размещать названия пакетов по алфавиту для удобства чтения. 

Для наглядности: официальный пример из документации Docker, где все эти рекоммендации учтены:
```
RUN apt-get update && apt-get install -y \
    aufs-tools \
    automake \
    build-essential \
    curl \
    dpkg-sig \
    libcap-dev \
    libsqlite3-dev \
    mercurial \
    reprepro \
    ruby1.9.1 \
    ruby1.9.1-dev \
    s3cmd=1.1.* \
    && rm -rf /var/lib/apt/lists/*
```
## Плохие практики работы с Docker
> В Readme описать 2 плохих практики по работе с контейнерами. ! Не по написанию докерфайлов, а о том, как даже используя хороший докерфайл можно накосячить именно в работе с контейнерами.

### 1. Относиться к контейнерам как к виртуальным машинам
Контейнеры это не виртуальные машины, мы не запускаем программы в контейнерах, напрямую не подключаемся, вручную не настраиваем ничего, не храним там данные. Контейнер идейно должен работать у каждого пользователя и разработчика одинаково. У вас нет надобности подключаться к контейнеру через ssh, устанавливать там программы и что-то чинить. После следующего ребута все эти изменения всё равно пропадут.

Необходимо помнить, что у контейнеров стоит задача заниматься одним процессом. 

## 2. Редкая перестройка образов
Билд образа это его снапшот в один единственный момент. Чтобы убедиться в том, что у образа все зависимости обновлены, документация Docker рекомендует часто их перестраивать. Ещё полезно прописать опцию`--no-cache` при перестройке, чтобы избежать кэш попаданий.
